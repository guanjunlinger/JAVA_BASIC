爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一 x，满足 0 < x < N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏

dp[i] = 1:当前局面为i,先手赢
dp[i] = 0:当前局面为i,先手输

dp[i] = 1   if dp[i-j]==0 && i%j==0

数学:
  终止态:N=2,先手必赢
  先手奇数,必输(对手肯定是偶数)
  先手偶数,必赢(每次选1,对手肯定是奇数)



猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。
给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。

dp[i][j]:在i-j之间猜测保证赢需要的最小现金
dp[i][j] =  max(k+dp[i][k-1],k+dp[k+1][j])   i<=k<=j

我能赢游戏:
给定一个整数maxChoosableInteger整数池中可选择的最大数,不允许重复选择）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？

你可以假设 maxChoosableInteger不会大于20， desiredTotal不会大于300。

/**
dp=new Boolean[1<<21]  状态对应的最优解
max：当前能取的最大值
total:当前查多少分到游戏结束
state:已选择数字的状态
*/
public boolean dfs(int max,int total,int state){
    if(total<=0) return false;
    if(dp[state]!=null){
        return dp[state];
    }
    for (int i=max;i>=1;i--) {
        if((state>>i&1)==0 && !dfs(max,total-i,state|(1<<i))){
            return dp[state]=true;
        }
    }
    return dp[state]=false;
}




