给你一个正整数数组arr，考虑所有满足以下条件的二叉树：
每个节点都有 0 个或是 2 个子节点。
数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）
每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。
在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和

key:中序遍历确定了树的构造方式,只能顺序分割

dp[i][j]:i-j之间的数字中序遍历得到的最小总和

dp[i][j] = min(dp[i][k]+dp[k+1][j],max(arr[i],arr[k])*max(arr[k+1],arr[j])) i<k<j


给定N,想象一个凸N边多边形,其顶点按顺时针顺序依次标记为A[0], A[i], ..., A[N-1]。
假设您将多边形剖分为N-2个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有N-2个三角形的值之和。
返回多边形进行三角剖分后可以得到的最低分

dp[i][j]:从i到j的顶点序列的最低分

dp[i][j]  =  min(dp[i][k]+dp[k][j]+A[i][j][k])  i<k<j




