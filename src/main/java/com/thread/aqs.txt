1.CountDownLatch
  state记录未签到的线程数
  await:尝试获取共享锁(state=0),若失败,则将自己加入等待队列,轮询前驱节点
  countDown:记录签到,CAS方式修改state=state-1,如果修改之后state=0,则从头结点开始唤醒等待队列中的线程


2.Semaphore
  state表示资源的数目
  acquire方法尝试获取共享锁(state>0),若失败,则直接将当前线程放入等待队列,轮询前驱节点
  release方法CAS方式释放资源,唤醒头结点后面被阻塞的线程
  支持公平锁


3.ReentrantLock
  state表示锁的状态
  exclusiveOwnerThread表示持有锁的进程
  支持公平锁
  lock:CAS方式获取排他锁,设置当前线程为锁的持有者;否则将自己加入等待队列,多次获取锁失败,则阻塞自己
  unlock:当前线程不是锁的持有者,直接抛异常;否则设置state=state-1,如果state=0,则唤醒队列头阻塞线程


4.ConditionObject
  firstWaiter表示等待队列头
  lastWaiter表示等待队列尾
  await:将当前线程加入条件队列,释放排它锁,LockSupport.park方法阻塞当前线程在队列同步器
  notify:将条件队列的首节点加入等待队列,LockSupport.unpark方法唤醒阻塞线程
  signalAll:将条件队列的所有节点加入等待队列,LockSupport.unpark方法唤醒阻塞线程

5.ReentrantReadWriteLock
  readerLock表示包装的读锁
  writerLock表示包装的写锁
  sync表示真正的锁实例
  SHARED_SHIFT   = 16                      共享锁的移位偏移量
  SHARED_UNIT    = (1 << SHARED_SHIFT)     读锁的单位增量
  EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1 写锁的掩码

  static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }


  static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }


